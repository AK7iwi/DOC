
General:

#include <netinet/in.h> : lib for struct sockaddr_in6

Server:

1) init_address_structures method:

Init the struct sockaddr_in6

The struct sockaddr_in6:

struct sockaddr_in6 
{
    uint16_t        sin6_family;   /* AF_INET6 */
    uint16_t        sin6_port;     /* numéro de port */
    uint32_t        sin6_flowinfo; /* information de flux IPv6 */
    struct in6_addr sin6_addr;     /* adresse IPv6 */
    uint32_t        sin6_scope_id; /* Scope ID (nouveauté 2.4) */
};

a) Clearing the Structure:

memset(&server_addr, 0, sizeof(server_addr));
This clears the server_addr structure to ensure there are no residual values from previous operations.

b) Setting the Address Family:

server_addr.sin_family = AF_INET6;
This sets the address family to IPv6. For IPv4, you would use AF_INET.

c) Setting the Port:

server_addr.sin_port = htons(port);
This sets the port number the server will listen on. 
The htons function converts the port number from host byte order to network byte order, which is required for correct communication over the network.

d) Setting the IP Address:

server_addr.sin_addr.s_addr = in6addr_any;
This allows the server to accept connections on any of the host’s IP addresses. in6addr_any is typically used in servers to listen on all available interfaces.

Goal: The initialized server_addr structure is then used in the bind system call to bind the server socket to the specified address and port.

2) socket(int domain, int type, int protocol);

a) domain (or address family):

AF_INET: Specifies the address family for the socket. AF_INET means the socket will use the IPv4 protocol.
For IPv6, you would use AF_INET6.

b) type:

SOCK_STREAM: Specifies the socket type. SOCK_STREAM indicates that the socket will provide sequenced, reliable, two-way, connection-based byte streams. This is typically used for TCP connections.
Other options include SOCK_DGRAM for datagram-based connections (UDP), SOCK_RAW for raw sockets, etc.

c) protocol:

0: Specifies the protocol to be used with the socket. 0 means that the system should choose the default protocol for the given combination of domain and type. For AF_INET and SOCK_STREAM, this usually means the TCP protocol.

d) Return Value
The function returns a file descriptor (an integer) that represents the socket. If the socket creation fails, it returns -1.
It return the server socket.

3) What is a non-blocking socket ?

Non-blocking I/O means that the I/O operations (such as reading from or writing to a socket) do not cause the program to wait if the operation cannot be completed immediately. 
Instead, the function returns immediately with an indication that the operation could not be completed right now. 
This is useful for high-performance servers that need to handle many connections simultaneously without being blocked by any single operation.

4) setsockopt() : 

Set the socket option (SO_REUSEADDR) to reuse the address

5) fcnt() : 

Set the socket option (O_NONBLOCK) for non-blocking socket

6) bind() : 

Bind the socket to the address

7) listen() : 

Listen for incoming connections and making the socket a passive socket

8) poll() : 

The poll function in C is used for multiplexing input/output over a set of file descriptors. 
It waits for one or more file descriptors to become "ready" for some class of I/O operation (e.g., input possible). 
This is useful in scenarios like network programming, where you want to manage multiple client connections simultaneously without using multi-threading.

Struct pollfd:

struct pollfd {
    int   fd;         /* Descripteur de fichier */
    short events;     /* Événements attendus    */
    short revents;    /* Événements détectés    */
};


9) accept()

Comme socket~~


10) recv()

Lis les connections des clients 


Client:


Commands:

1) CAP LS
2) NICK

3) USER

4) JOIN

5) PRIVMSG

