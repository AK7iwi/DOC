
0) Struct: Each class have their own mains --> cpp09

1) Private, protected, public

Private: Can be used only by the methode in the class(in the class(.cpp)?). Acces to all variable in the class.

Protected: Private but inherited class can also use the variable or the method

Public: Can be used anywhere, in the mthode or directly by the object. Acces to all variable in the class.

vs 

//rewrite

Static methode : 
Dans le .hpp vs dans le .cpp

Dans le .cpp comme en C. La fct n'est utilise que dans le fichier et il ne faut pas la redeclarer dans le .hpp
Dans le point .hpp la fct est utiliser en dehors du fichier mais elle n'est pas instantiable. ex: cpp06/ex00 (static void convert) 

Static functions :

-Functions used uniquement dans le fichier comme en C mais contrairement au methode private, il n a pas acces au variable de la classe
Ne peut pas se declarer dans le .hpp

 Methode static/ static fct :

a) static methode ne s'utilise pas sur un object (voir cpp06/ex00)

a) Static fct ne partage pas les attributs public, private ou protected
	Ne s'utilise pas sur un object (voir cpp06/ex00)

b) Fct static: comme en C

Example : 

class BitcoinExchange

void BitcoinExchange::exchange() <=> a declarer dans le .hpp (pas static)

void exchange(), si utiliser que dans le meme .cpp --> static void exchange() (static) 
--> pas a declarer dans le .hpp


2) Pointeur et adresse C++ vs C

https://cpp.developpez.com/cours/cpp/?page=page_6

C : 

The & operator is used to obtain the memory address of a variable.
The * operator is used to access the value pointed to by a pointer.

C++ : ~~~~~~~

obtain memory addresses using the & operator and
access values using the * operator for pointers. 
The reference stringREF behaves similarly to a pointer but 
is more like an alias

Voir cpp_pool cpp01/ex02


3) Constructeur/cpy Constructeur/ destructor

	CPP02:
	
	int main(void)
	{
		Fixed a;
		Fixed b(a);
		Fixed c;
	
		c = b;
	
		return 0;
	}

	Fixed(a) : Appel le default constructor
	Fixed b (a) : appelle copy comstructor 
	FIxed c: Appel le default constructor
	c = b : Appel le copy assignement operator


	Forme canonical : https://scg.unibe.ch/download/p2/11Cpp.pdf page 28

	class MyClass 
	{
		public:
			MyClass(void);   // default constructor
			MyClass(MyClass const &copy); // copy constructor
			...     					// other constructors
			~MyClass(void);   // destructor
			MyClass& operator=(MyClass const &rhs); // assignement
			...    	// other public member functions 
		private: 
	}

	deep copy vs shallow copy 

4) Const Rules

In methode, functions:

In C++, the placement of const in a function declaration specifies whether the function itself is constant or if the returned value is constant. Let's break down the two function declarations you provided:

int get_grade() const;
int const get_grade();
int get_grade(const &var);

1. int get_grade() const;

This prototype indicates a member function of a class. 
The const at the end of the function declaration means that this member function is a "const member function". 
It implies that the member function doesn't modify the state of the object on which it's called. 
In other words, it promises not to modify any member variables of the class. 
This is often used to prevent unintended modification of member variables when calling a member function on a const object.

2. int const get_grade();

This prototype declares a function that returns an int const. 
This means that the returned integer value is constant, and cannot be modified. 
However, this doesn't specify anything about the function itself. It could be a standalone function or a member function. 
If it's a member function, it's not a const member function, which means it can modify the state of the object.

3. int get_grade(const &var);

This prototype declares a function that takes a constant reference (const &) to some variable (var). 
This is typically used when you want to pass a parameter to a function without allowing that function to modify the parameter. 
It's useful for functions that need to read but not modify the passed object.

When to Use Them:

int get_grade() const; : 

Use this when defining a member function that doesn't modify the state of the object. 
This is especially useful in situations where you're dealing with const objects or when you want to ensure the function doesn't inadvertently modify the object.

int const get_grade(); : 

This is less common in practice. It's used when you want to return a constant value. 
However, it's generally better to return primitive types directly rather than returning them as constants.

int get_grade(const &var); : 

Use this when you want to pass a parameter by reference to a function but don't want the function to modify the original value of the parameter. 
It's particularly useful when dealing with large objects where passing by value would be inefficient or when you want to guarantee that the original object remains unchanged.


For the catch : 

When writing a catch block in C++ to catch exceptions, you generally have two options:

catch (std::exception &e): This catches exceptions by non-const reference. It allows you to modify the caught exception object within the catch block. 
However, modifying the caught exception object is not common practice and may not be necessary in most situations. 
Also, using non-const references in the catch block can lead to unintended modifications and might not be the best practice unless you have a specific need to modify the exception object.

catch (std::exception const &e): This catches exceptions by const reference. 
It prevents you from modifying the caught exception object within the catch block.
Catching exceptions by const reference is generally considered safer and more idiomatic, as it ensures that the caught exception object remains unchanged.
In summary, it's generally recommended to use catch (std::exception const &e) unless you have a specific reason to modify the caught exception object, in which case you might use catch (std::exception &e). 
However, modifying the exception object is rare and should be done judiciously.


To good to know : You can const if you only have to cast. Cast not change the value.

5) Cast 

https://www.geeksforgeeks.org/dynamic-_cast-in-cpp/


6) Exception //rewrite

En "catchant" l'exeption

.what

Liste class exception : 

See : "Exception categories
https://en.cppreference.com/w/cpp/error

Can be throw and catch.

No need to be throw, to be catch 

Ex: 

try 
{
	(void)dynamic_cast<C &>(p);
	std::cout << "Identify(Base &p): C" << std::endl;
} 
catch (std::exception const &e)
{std::cout  << "Identify(Base &p): NULL" << std::endl;}

Class exception I used most: 

I) std::exception --> use in general
 
II) std::invalid_argument --> use for an invalid argument 

III) std::out_of_range --> 

IV) std::length_error --> 

V) std::runtime_error --> 

Print l'erreur en utilisant .what

If own exception class and general exception : First class the own exception and after the general. (See cpp05/ex03 test4)  
Si classe d'exception perso + exception de base. First catch the  


7) Container 

https://en.cppreference.com/w/cpp/container

https://cplusplus.com/reference/stl/

Different types : 

a) Vector 

https://cplusplus.com/reference/vector/vector/

.find

Print : 

for (std::vector<std::pair<int, int> >::iterator it = _vector.begin(); it != _vector.end(); it++)
		std::cout << it->first << " ";

b) Map 

https://cplusplus.com/reference/map/map/

container of key-value pairs

2 valeur --> it->first, it->second

Print a map container std::map<T, T> _database :
for (std::map<T, T>::iterator it = _database.begin(); it != _database.end(); ++it)
        std::cout << it->first << " && " << it->second << std::endl;

Ne marche pas directement avec la methode .find:

std::map<std::string, double>::const_iterator it = database.find(date); OK

std::map<std::string, double>::iterator it = std::find(database.begin(), database.end(), date); X

c) Stack 

https://en.cppreference.com/w/cpp/container/stack

Print a stack container std::stack<T> _stack :
while (!_stack.empty()) 
{
        std::cout << _stack.top() << " ";
        _stack.pop();
}
    std::cout << std::endl;

stack dot have .clear() methode 

d) Deque

https://cplusplus.com/reference/deque/deque/

Why use a type:

How to use it, how to print it, how to copy container in cpy constructor :

Different utils fct : .find(), .begin() .end() .top() .push() .pop() .clear() 

8) Template fct 


9)  DIfferent type de stream

https://cplusplus.com/reference/iolibrary/

a) istream: input stream

https://cplusplus.com/reference/istream/istream/


ifstream : input file stream

https://cplusplus.com/reference/fstream/ifstream/

istringstream : input string stream

https://cplusplus.com/reference/sstream/istringstream/

b) iostream: 

c) ostream: 

I) List include utils :


<iostream> : stream variable

<stdexcept> : catch, try, throw, exception class

<stdint.h> : uint8_t

<stdlib.h> : EXIT_FAILURE, EXIT_SUCCES


10) Inline in c++

https://stackoverflow.com/questions/9338152/must-the-definition-of-a-c-inline-functions-be-in-the-same-file

11) const and &

Ex(cpp05/ex00) :

Bureaucrat::Bureaucrat(const std::string &name, int grade) : 
    _name(name)
{
    if (grade < 1)
        throw grade_too_high_exception();
    else if (grade > 150)
        throw grade_too_low_exception();
        
    _grade = grade;
}

a) is it good to write & before te grade ?

In the case of the int grade parameter, it is generally not necessary or beneficial to use a reference (int &grade) or a const reference (const int &grade). 
This is because int is a small, built-in type that is cheap to copy. 
Using a reference for such types can actually be less efficient due to the overhead of reference handling.

Here's why you should use int directly for the grade parameter:

    Efficiency: Copying an int is extremely cheap and likely more efficient than the cost of dereferencing a reference.
    Simplicity: Passing small built-in types like int by value keeps the code simple and straightforward.

Summary

    Use const std::string & for the name parameter: This avoids unnecessary copying of potentially large objects.
    Use int for the grade parameter: This is simple, efficient, and suitable for small built-in types.

b) why not const before grade ?

Using const before the int grade parameter in the constructor signature would not provide any additional benefits and might actually lead to confusion. Here's why:

Value Parameters are Immutable by Default: When a parameter is passed by value, the function receives a copy of the argument. 
Modifying this copy does not affect the original argument passed to the function. 
Since the copy is local to the function, it does not need to be declared const to prevent modification outside the function.

Clarity: Declaring const int grade in the parameter list might imply that the parameter is being passed by reference or pointer, which can be misleading. 
It is more common and clearer to use const with reference or pointer types.

Convention: By convention, small built-in types like int, char, float, and double are passed by value without const in the parameter list. 
This is standard practice in C++ and aligns with typical expectations of other developers reading your code.

Summary

In this specific context, adding const before int grade in the constructor parameter list does not provide any meaningful benefits and can detract from the clarity and readability of the code. 
The conventional and idiomatic approach is to pass such parameters by value without const.