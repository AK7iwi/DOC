
0) Struct: Each class have their own mains --> cpp09

0) Private, protected, public

Private: Can be used only by the methode in the class(in the class(.cpp)?). Acces to all variable in the class.

Protected: Private but inherited class can also use the variable or the method

Public: Can be used anywhere, in the mthode or directly by the object. Acces to all variable in the class.

vs 

Static methode : 

Static functions :

-Functions used uniquement dans le fichier comme en C mais contrairement au methode private, il n a pas acces au variable de la classe
Ne peut pas se declarer dans le .hpp

1) Pointeur et adresse C++ vs C

https://cpp.developpez.com/cours/cpp/?page=page_6

C : 

The & operator is used to obtain the memory address of a variable.
The * operator is used to access the value pointed to by a pointer.

C++ : 

obtain memory addresses using the & operator and
access values using the * operator for pointers. 
The reference stringREF behaves similarly to a pointer but 
is more like an alias

Voir cpp_pool cpp01/ex02

2) Constructeur/cpy Constructeur/ destructor

	CPP02:
	
	int main(void)
	{
		Fixed a;
		Fixed b(a);
		Fixed c;
	
		c = b;
	
		std::cout << a.getRawBits() << std::endl;
		std::cout << b.getRawBits() << std::endl;
		std::cout << c.getRawBits() << std::endl;
		return 0;
	}

	Fixed(a) : Appel le default constructor
	Fixed b (a) : appelle copy comstructor 
	FIxed c: Appel le default constructor
	c = b : Appel le copy assignement operator


	Forme canonical : https://scg.unibe.ch/download/p2/11Cpp.pdf page 28

	class MyClass 
	{
		public:
			MyClass(void);   // default constructor
			MyClass(MyClass const &copy); // copy constructor
			...     					// other constructors
			~MyClass(void);   // destructor
			MyClass& operator=(MyClass const &rhs); // assignment
			...    	// other public member functions 
		private: 
	}


	deep copy vs shallow copy 

3) Static methode dasns le .hpp vs dans le .cpp

Dans le .cpp comme en C. La fct n'est utilise que dans le fichier et il ne faut pas la redeclarer dans le .hpp
Dans le point .hpp la fct est utiliser en dehors du fichier mais elle n'est pas instantiable. ex: cpp06/ex00 (static void convert) 

3.5) const rules

In C++, the placement of const in a function declaration specifies whether the function itself is constant or if the returned value is constant. Let's break down the two function declarations you provided:

uint8_t inline get_grade() const;
uint8_t const inline get_grade();

In the first declaration:

cpp
Copy code
uint8_t inline get_grade() const;
The function get_grade() is declared as a member function of some class or struct.
The const keyword at the end indicates that the member function get_grade() is a "const member function". This means that when this member function is called on a const object of the class or struct, it promises not to modify the object's data members.
This function returns a uint8_t type.
inline suggests that the function should be inlined by the compiler if possible. This is a hint to the compiler to replace calls to this function with the function's code directly where it's called.
In the second declaration:

cpp
Copy code
uint8_t const inline get_grade();
This function declaration returns a const uint8_t. In this context, const applies to the return value rather than the function itself. It means that the value returned by get_grade() is const, i.e., it cannot be modified.
The function itself is not declared as const, so it doesn't guarantee not to modify any class/struct data members. It's just a regular member function that returns a constant value.
inline suggests the same behavior as in the first declaration.
So, in summary:

In the first declaration, const applies to the member function itself, making it a const member function. The return value is not const.
In the second declaration, const applies to the return value, making it a const value. The member function itself is not const

4) Cast 

https://www.geeksforgeeks.org/dynamic-_cast-in-cpp/


5) Exception

En "catchant" l'exeption

.what

Liste class exception : 

See : "Exception categories
https://en.cppreference.com/w/cpp/error

Can be throw and catch.

No need to be throw, to be catch 

Ex: 

try 
{
	(void)dynamic_cast<C &>(p);
	std::cout << "Identify(Base &p): C" << std::endl;
	return ;
} 
catch (std::exception const &e)
{std::cout  << "Identify(Base &p): NULL" << std::endl;}

Class exception I used: 

I) std::exception --> use in general
 
II) std::invalid_argument --> use for an invalid argument 

III) std::out_of_range --> 

IV) std::length_error --> 

V) std::runtime_error --> 

Print l'erreur en utilisant .what


7) Methode static/ static fct

a) static methode Ne s'utilise pas sur un object (voir cpp06/ex00)

a) Static fct ne partage pas les attributs public, private ou protected
	Ne s'utilise pas sur un object (voir cpp06/ex00)

b) Fct static: comme en C

Example : 

class BitcoinExchange

void BitcoinExchange::exchange() <=> a declarer dans le .hpp (pas static)

void exchange(), si utiliser que dans le meme .cpp --> static void exchange() (static) 
--> pas a declarer dans le .hpp


9) Container 

https://en.cppreference.com/w/cpp/container

https://cplusplus.com/reference/stl/

Different types : 

a) Vector 

https://cplusplus.com/reference/vector/vector/

.find

Print : 

for (std::vector<std::pair<int, int> >::iterator it = _vector.begin(); it != _vector.end(); it++)
		std::cout << it->first << " ";

b) Map 

https://cplusplus.com/reference/map/map/

container of key-value pairs

2 valeur --> it->first, it->second

Print a map container std::map<T, T> _database :
for (std::map<T, T>::iterator it = _database.begin(); it != _database.end(); ++it)
        std::cout << it->first << " && " << it->second << std::endl;

Ne marche pas directement avec la methode .find:

std::map<std::string, double>::const_iterator it = database.find(date); OK

std::map<std::string, double>::iterator it = std::find(database.begin(), database.end(), date); X

c) Stack 

https://en.cppreference.com/w/cpp/container/stack

Print a stack container std::stack<T> _stack :
while (!_stack.empty()) 
{
        std::cout << _stack.top() << " ";
        _stack.pop();
}
    std::cout << std::endl;

stack dot have .clear() methode 

d) Deque

https://cplusplus.com/reference/deque/deque/

Why use a type:

How to use it, how to print it, how to copy container in cpy constructor :

Different utils fct : .find(), .begin() .end() .top() .push() .pop() .clear() 

10) Template fct 


11)  DIfferent type de stream

https://cplusplus.com/reference/iolibrary/

a) istream: input stream

https://cplusplus.com/reference/istream/istream/


ifstream : input file stream

https://cplusplus.com/reference/fstream/ifstream/

istringstream : input string stream

https://cplusplus.com/reference/sstream/istringstream/

b) iostream: 

c) ostream: 



x) List include utils :


<iostream> : stream variable

<stdexcept> : catch, try, throw, exception class

<stdint.h> : uint8_t

<stdlib.h> : EXIT_FAILURE, EXIT_SUCCES

